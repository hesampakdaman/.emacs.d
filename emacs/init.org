# -*- after-save-hook: (org-babel-tangle); before-save-hook: (delete-trailing-whitespace)-*-
#+TITLE: Emacs configuration
#+AUTHOR: Hesam Pakdaman
#+STARTUP: overview
#+PROPERTY: header-args :mkdrip yes :tangle-mode o444 :results silent :tangle (concat user-emacs-directory "init.el")
* Introduction
This Emacs configuration will be tangled to =init.el= inside Emacs'
configuration directory -- usually =~/.emacs.d= -- with one exception:
the code in subsection [[Early initialization]] below will be tangled to the
same directory as =early-init.el=.

* Early initialization
:PROPERTIES:
:header-args: :tangle (concat user-emacs-directory "early-init.el")
:END:
#+begin_src emacs-lisp
  ;; Increase garbage collection threshold to delay GC during startup.
  ;; this decreases startup time.
  (setq gc-cons-threshold (* 100 (expt 10 6)) ; 100MB
        gc-cons-percentage 0.8)

  ;; Skip handling special file during startup. This decreases start
  ;; time.
  (defvar startup/file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)

  ;; Lower garbage collection threshold after startup to minimize impact
  ;; of GC during normal use. Reset file-name-handler-alist.
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 50 (expt 10 6)) ; 50MB
                    gc-cons-percentage 0.1
                    file-name-handler-alist startup/file-name-handler-alist)))

  ;; Frame decorations and size
  ;; do not allow Emacs to resize frame
  (setq frame-inhibit-implied-resize t)

  (setq frame-resize-pixelwise t)
  (setq idle-update-delay 0.1)
  (setq fast-but-imprecise-scrolling t)
  (setq pixel-scroll-precision-mode t)

  ;; set these early to reduce flickering/resizing on startup
  (setq default-frame-alist '((width . 70) (height . 35)))
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)

  ;; load a default theme
  (load-theme 'modus-vivendi t)
  (set-face-attribute 'fringe nil :background 'unspecified)

  (dolist (frame-option
           '((undecorated . t) (internal-border-width . 15) (drag-internal-border . 5)))
    (add-to-list 'default-frame-alist frame-option))

  ;; Package
  (setq package-check-signature nil)
  (setq package-native-compile t)         ; compile package ahead-of-time
  (setq package-quickstart t)

  ;; Compilations
  ;; warning: with 3, the compiler is free to perform dangerous optimizations.
  (setq-default native-comp-speed 3) ;; -O3

  ;; Warnings
  (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local cl-functions))
  (setq native-comp-async-report-warnings-errors 'silent)
  (setq warning-suppress-types '((comp)))

  ;; Misc Optimizations
  (setq-default cursor-in-non-selected-windows nil)
#+end_src

* Global settings
It is of most important that this file is loaded first. Here we define
global variables, such as theme-colors, that are
assumed to exists in other configuration files.

In this file we define global variables to be consumed in other
files. For example, theming variables for colors too.

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-defer t
        use-package-always-ensure t)

  (use-package package
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/")))

  ;; follow symlinks without prompt
  (setq vc-follow-symlinks t)
#+end_src

** Face group
We define a customization group that we can use as a parent for all
other `defcustom` commands. If we ever search for groups in
`customize` we can easily find them.
#+begin_src emacs-lisp
  (defgroup hesam nil
    "Parent group for my personal Emacs customization settings."
    :group 'emacs)
#+end_src

** Theme hooks
These are used to override certain faces defined by the theme
author. Any function added to the hook receives the theme symbol and
is run either after `(load-theme ...)` or `(enable-theme ...)`. Usage
is simple `(add-hook 'after-load-theme-hook (lambda (theme) body))`.
#+begin_src emacs-lisp
  (defvar after-load-theme-hook nil
    "Hook run after a theme is loaded using `load-theme'.")

  (defun run-after-load-theme-hook (theme &rest args)
    "Run `after-load-theme-hook' with theme as argument."
    (sit-for 0.5)
    (run-hook-with-args 'after-load-theme-hook theme))

  (advice-add 'load-theme :after #'run-after-load-theme-hook)
  (advice-add 'enable-theme :after #'run-after-load-theme-hook)
#+end_src

* General settings
This file encapsulates a collection of global settings and
configurations that influence the behavior of Emacs across various
domains. From handling autosaves and backups to managing calendars,
bookmarks, server settings, and performance tweaks, these
configurations contribute to the overall usability, functionality, and
personalization of the Emacs environment. Detailed sections within
this file allow for fine-tuned adjustments to individual aspects,
promoting a coherent and unified configuration tailored to specific
user needs.

** Performance Optimizations
Optimizations that improve the general performance of Emacs.
#+begin_src emacs-lisp
  ;; Increase the amount of data read from subprocesses
  (setq read-process-output-max (* 1 (expt 10 6))) ; 1MB
#+end_src

** Autosave and Backups
Saves all backups to user's Emacs directory and in addition creates
numbered backups. First things first, we create autosave and backup
directory where we put autosaves and backups respectevily.
#+begin_src emacs-lisp
  (defcustom hesam-autosave-directory (expand-file-name "autosave/" user-emacs-directory)
    "Directory where autosave and backups are put."
    :type 'directory
    :group 'hesam)

  (defcustom hesam-backup-directory (expand-file-name "backup/" user-emacs-directory)
    "Directory where autosave and backups are put."
    :type 'directory
    :group 'hesam)
#+end_src

Of course we need to make sure these directories exists
#+begin_src emacs-lisp
  (dolist (dir (list hesam-autosave-directory hesam-backup-directory))
    (unless (file-directory-p dir)
      (make-directory dir)))
#+end_src

Use the directory for backups. There are some other sane settings used
described below with comments.
#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,hesam-backup-directory))
	version-control t		  ; Use version numbers for backups.
	vc-make-backup-files t	  ; Make backups for git files
	kept-new-versions 1000	  ; Number of newest versions to keep.
	kept-old-versions 0	  ; Number of oldest versions to keep.
	delete-old-versions t ; Don't ask to delete excess backup versions.
	backup-by-copying t)  ; Copy all files, don't rename them.
#+end_src

But backups are only created once when the buffer is visited. We want
to save backups on each save. We do so by resetting the flag that
tells Emacs that the file has been backed up. Adding a hook to do that
after each save will make Emacs backup the file since the counter has
been reset.
#+begin_src emacs-lisp
  (defun force-backup-of-buffer ()
    (setq buffer-backed-up nil))
  (add-hook 'before-save-hook  'force-backup-of-buffer)
#+end_src

We also make sure to organize our autosaves in user's Emacs directory.
#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms
	`((".*" ,hesam-autosave-directory t)))
#+end_src

** Bookmarks
Saving bookmarks to Dropbox and auto-saving upon change.
#+begin_src emacs-lisp
  (setq bookmark-default-file "~/Dropbox/emacs/bookmarks"
        ;; num changes before saving bookmark
        bookmark-save-flag 1)
#+end_src

** Calendar and Time
Configuration for calendar, setting ISO formats and start of week.
#+begin_src emacs-lisp
  ;; start with Mon
  (setq calendar-week-start-day 1)

  ;; EU style
  (setq calendar-date-style 'european)

  ;; Date format
  (setq calendar-date-display-form
        '((if dayname
              (concat dayname ", "))
          day " " monthname " " year))

  ;; 24-clock
  (setq calendar-time-display-form
        '(24-hours ":" minutes))

  ;; show week numbers
  (setq calendar-intermonth-text
        '(propertize
          (format "W%2d"
                  (car
                   (calendar-iso-from-absolute
                    (calendar-absolute-from-gregorian (list month day year)))))
          'font-lock-face 'calendar-iso-week-face))
#+end_src

And if we ever need it the display is on 24h format, we don't display
load-average
#+begin_src emacs-lisp
  (setq display-time-24hr-format t
        display-time-day-and-date nil
        display-time-default-load-average nil)
#+end_src

** Custom file settings
Emacs customization options are not tracked by git and will be saved
in another file instead of in this init file.
#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/emacs-custom.el")
  (if (file-exists-p custom-file)
      (load-file custom-file))
#+end_src

** Disable suspend functions
We don't want to ever suspend Emacs or the frame. Therefore display a
warning when these commands are run.
#+begin_src emacs-lisp
  (put 'suspend-frame 'disabled t)
  (put 'suspend-emacs 'disabled t)
#+end_src

** Help
When spawning new `*Help*` buffers we select them (for ease of
quitting with `q`) and tell Emacs to reuse the same window for all
`*Help*` related buffers.
#+begin_src emacs-lisp
  (setq help-window-select t
        help-window-keep-selected t)      ; reuse help window for related buffers
#+end_src

** Inhibiting Bells and Warnings
Finding it too annoying hearing beeping sounds and seeing visual we
alamrs we turn all of them completely off.
#+begin_src emacs-lisp
  ;; no beeping
  (setq ring-bell-function 'ignore)
  (setq server-client-instructions nil)
#+end_src

** Openwith
A package that helps with opening files in an external app, such as
opening `.doc` files in `libreoffice`.
#+begin_src emacs-lisp
  (use-package openwith
    :config
    (setq openwith-associations
          (list
           (list (openwith-make-extension-regexp
                  '("mpg" "mpeg" "mp3" "mp4"
                    "avi" "wmv" "wav" "mov" "flv"
                    "ogm" "ogg" "mkv" "rar"))
                 "mpv --no-border"
                 '(file))))
    (openwith-mode 1))
#+end_src

** Repeat mode
Allows us to repeat commands. For example, to use the next tab command
we do "C-x t o" twice. But with repeat mode it suffices to do "C-x t
o" once and followed by arbitrarily many "o".
#+begin_src emacs-lisp
  (repeat-mode t)
#+end_src

** Reverting
Will automatically load changed buffers, this can for example happen
if we use git to reset recent changes.
#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src

And make use of the quick revert setting when reverting files with
`C-x x g`
#+begin_src emacs-lisp
  (setq revert-buffer-quick-short-answers t)
#+end_src

** Savehist mode
Save minibuffer commands in a file that is loaded at startup
#+begin_src emacs-lisp
  (savehist-mode t)
#+end_src

** Sentence end space
One of the ways Emacs recognizes sentences is by a '.', ',', '?' or
'!' followed by _two_ spaces. Hence sentence commands such as `M-k`
will not work properly for text that does not follow this convention.
We change it here so that only _one_ space is needed.
#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src

The drawback now is that Emacs cannot distinguish between periods used
in abbreviations and those that mark an end to a sentence. Consider
#+begin_quote
Mt. Everest is Earth's highest mountain.
#+end_quote

Putting the cursor at the character `M` in the quote above and
pressing `M-e` leaves us in the space between `Mt.` and `Everest`.

** Subword
Allows for moving over a word based on the subwords in the table
below. From the manual we have a table to show us the meaning of this
minor mode.

|-------------------+--------------------------------|
| Nomenclature      | Subwords                       |
|-------------------+--------------------------------|
| GtkWindow         | "Gtk" and "Window"             |
| EmacsFrameClass   | "Emacs", "Frame" and "Class"   |
| NSGraphicsContext | "NS", "Graphics" and "Context" |
|-------------------+--------------------------------|

#+begin_src emacs-lisp
  (global-subword-mode 1)
#+end_src

** Narrow
Allow narrowing `C-x n n` to a region. It makes sense to have it off
and warn the user by default. But once you familiarize with the mode
it's okay to allow it. Simply put, this command lets you only display
the region you selected.
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+end_src

** Start-up time
It's a good idea to be aware of Emacs' startup time. In case any new setting has dramatic effect on it, this should hopefully make you aware.
#+begin_src emacs-lisp
  (defun hesam/display-startup-time ()
    (message
     "Emacs loaded in %s with %d garbage collections."
     (emacs-init-time) gcs-done))
  (add-hook 'emacs-startup-hook #'hesam/display-startup-time)
#+end_src

* Completion settings
** Corfu
General autocompletion system, but mostly used in programming
contexts. We complete text with `TAB` across Emacs' buffers.
#+begin_src emacs-lisp
  (use-package corfu
    :demand t
    :custom
    (corfu-auto t)
    (corfu-cycle t)
    (corfu-preselect 'first)
    (corfu-preview-current nil)
    (corfu-quit-at-boundary nil)
    :bind (:map corfu-map
                ("TAB"     . corfu-insert)
                ([tab]     . corfu-insert)
                ("S-TAB"   . corfu-previous)
                ([backtab] . corfu-previous))
    :init
    (global-corfu-mode))

  ;; Do not cycle commands instead give me the corfu pop-up
  (setq completion-cycle-threshold nil)

  ;; Hide commands in M-x which do not apply to the current mode. Corfu
  ;; commands are hidden, since they are not supposed to be used via
  ;; M-x.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete)
#+end_src

** Orderless
Provides completion styles to be used on top-of a completion packages
such as `Vertico` or certain `Consult` functions. If we do `C-x C-f`
and have two files `languages-and-modes.org` and `general.org` then
the search string `g l` will match both if we have set `'orderless`
style (ie. the order of your serach words does not matter).
#+begin_src emacs-lisp
  (use-package orderless
    :demand t
    :config
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src

** Vertico
Minibuffer completion system. It will display a vertical scrolling
minibuffer in modes like `M-x` or `(find-file)`.
#+begin_src emacs-lisp
  (use-package vertico
    :demand t
    :init
    (vertico-mode)
    :config
    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
          (lambda (&rest args)
            (apply (if vertico-mode
                       #'consult-completion-in-region
                     #'completion--in-region)
                   args))))
#+end_src

* Editing settings
** Custom editing functions
Here we define custom functions that we use for editing simple
text.
*** Function definitions
Now we define the functionality we bound above. For copying several
lines of text this function below is a snipppet found on the Internet.
#+begin_src emacs-lisp
  (defun edit/copy-line (arg)
    "Copy lines (as many as prefix argument) in the kill ring.
        Ease of use features:
        - Move to start of next line.
        - Appends the copy on sequential calls.
        - Use newline as last char even on the last line of the buffer.
        - If region is active, copy its lines."
    (interactive "p")
    (let ((beg (line-beginning-position))
          (end (line-end-position arg)))
      (when mark-active
        (if (> (point) (mark))
            (setq beg (save-excursion (goto-char (mark)) (line-beginning-position)))
          (setq end (save-excursion (goto-char (mark)) (line-end-position)))))
      (if (eq last-command 'copy-line)
          (kill-append (buffer-substring beg end) (< end beg))
        (kill-ring-save beg end)))
    (kill-append "\n" nil)
    (beginning-of-line (or (and arg (1+ arg)) 2))
    (if (and arg (not (= 1 arg))) (message "%d lines copied" arg)))
#+end_src

For vim-like deletion of a single word like we define this function
#+begin_src emacs-lisp
  (defun edit/delete-a-word (&optional args)
    "Vim-like deletion of a single word.
    Takes an optional integer argument ARGS to delete ARGS many
    words."
    (interactive "p")
    (forward-char 1)			;if at beg. of word
    (backward-word 1)
    (kill-word args))
#+end_src

Simple function to delete blank lines from cursor downwards.
#+begin_src emacs-lisp
  (defun edit/remove-blank-lines ()
    (interactive)
    (flush-lines "^$"))
#+end_src

** sudo-edit
When buffer is locked for editing due to permissons we can use this
package to make editing with sudo access easily. We extensively use
either `(sudo-edit-current-file)` or `(sudo-edit-find-file)`.
#+begin_src emacs-lisp
  (use-package sudo-edit)
#+end_src

* Keybindings settings
Here we define misc shortcuts to other programs or commands. Then we
try and organize bindings depending on what they are used for.

All bindings are not defined here. Instead we have the another
philosophy of creating bindings where packages are defined. As such we
make extensive use of `use-package` and its `:bind` feature.

** C-c and C-x prefix bindings
For built-in modes that need no `use-package` or enabling of modes. We
separate between custom commands prefixed by `C-c` and shadowing emacs
default bindings defined with `C-x`.
*** Custom C-c bindings
#+begin_src emacs-lisp
;; empty
#+end_src

*** Shadowing emacs' C-x bindings
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

** Unset bindings
We want to unbind default bindings that aren't useful to us, such as
suspending.
#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
  (global-unset-key (kbd "C-x C-z"))
#+end_src

** macOS specific
Keybindings in macOS are a bit different compared to Linux. I'm
accustomed to Linux so here I will try and mimic its keybindings. Use
`Karabiner Elements` to bind keys according to the table below

|----------+---------|
| Key      | Binding |
|----------+---------|
| Capslock | Control |
| Command  | Fn      |
| Control  | Command |
|----------+---------|

#+begin_src emacs-lisp :tangle (if (eq system-type 'darwin) (concat user-emacs-directory "init.el") "no")
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super)
  (setq ns-function-modifier 'hyper)
#+end_src

We'll need to do some modifications to keys used by macOS; otherwise
they will interfere with the setup above. For it to work we require
`skhd` with the following config

#+begin_src bash :tangle (if (eq system-type 'darwin) "~/.skhdrc" "no")
  fn - n : skhd --key "f14"
  fn - c : skhd --key "f15"
  fn - a : skhd --key "f16"
  fn - b : skhd --key "f17"
#+end_src
and let Emacs know about it
#+begin_src emacs-lisp :tangle (if (eq system-type 'darwin) (concat user-emacs-directory "init.el") "no")
  (global-set-key (kbd "§") (kbd "`"))
  (global-set-key (kbd "±") (kbd "~"))
  (global-unset-key (kbd "M-`"))
  (global-unset-key (kbd "`"))
#+end_src

* Miscellaneous Packages
This is not an exhaustive list of all packages used in our
configuration. Rather we have put packages here that we couldn't
motivate putting elsewhere under our directory tree.

For example, in `programming.org` we have declared `magit`
package. But it makes sense to have it there since it has a clear
connection with programming.
** elfeed
RSS reader that we configure with org.
#+begin_src emacs-lisp
  (use-package elfeed
    :config
    (elfeed-org))

  (use-package elfeed-org
    :defer 2
    :config
    (setq rmh-elfeed-org-files
          (list (file-name-concat (expand-file-name "~") ".elfeed.org"))))
#+end_src

** embark
A package that provides a minibuffer UI for actions on things. We install =embark= and =embark-consult= for previewing targets.
#+begin_src emacs-lisp
  (use-package embark
    :init
    (setq prefix-help-command #'embark-prefix-help-command)
    :bind
    (("C-." . embark-act)
     ("C-;" . embark-dwim)
     ("C-h B" . embark-bindings))
    :config
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
By default =embark= will show a preview window. We don't want that and instead prefer a =which-key= like popup. We can do that by adding the following to our config, directly copied from [[https://github.com/oantolin/embark/wiki/Additional-Configuration#use-which-key-like-a-key-menu-prompt][the wiki]].
#+begin_src emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
    '(embark-which-key-indicator
      embark-highlight-indicator
      embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
        (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)

#+end_src
** expand region
Will expand mark in regions that makes sense, ie. is context aware.
#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-c =" . 'er/expand-region))
#+end_src

** pdf-tools
A major mode for viewing PDF files inside Emacs. Ordinary `'isearch`
works best in PDF tools which is why we explicitly set it for
`PDFView` mode.
#+begin_src emacs-lisp
  (use-package pdf-tools
    :init
    (setq pdf-view-use-unicode-ligther nil
          pdf-view-use-scaling nil)
    :hook ((doc-view-mode . pdf-tools-install)
           (after-load-theme . (lambda (theme)
                                (setq pdf-view-midnight-colors
                                      (cons (face-attribute 'default :foreground)
                                            (face-attribute 'default :background))))))
    :bind (:map pdf-view-mode-map
                ("C-s" . isearch-forward)
                ("C-r" . isearch-backward)
                ("<mouse-8>" . pdf-view-previous-page-command)
                ("<mouse-9>" . pdf-view-next-page-command)))
#+end_src

* Org mode settings
At this point we assume `Org` is required and ready to go. This is
safe because in our `init.el` we use babel to load all modules and
therefore `Org` is required.

First set up our org mode directory
#+begin_src emacs-lisp
  (defcustom hesam-org-directory "~/Dropbox/org"
    "Default directory for where Org will look at put files."
    :type 'directory
    :group 'hesam)
  (setq org-directory hesam-org-directory)
#+end_src

We want to display Org SRC code blocks in the same window
#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src

When invoking `imenu` we would like to search through at least 5
subsections.
#+begin_src emacs-lisp
  (setq org-imenu-depth 5)
#+end_src

** Agenda and GTD
Agenda files are stored in Dropbox under `org/agenda`. If we put our
GTD file inside `org-agenda-files`, then any dates in the GTD file
will be seen by org agenda. We also define some nice tags to use so
that we can filter on them in the Agenda view.
#+begin_src emacs-lisp
    (setq gtd-file (concat (eval org-directory) "/agenda/gtd.org"))
    (setq org-agenda-files `(,gtd-file)
          org-default-notes-file "~/Dropbox/org/notes.org"
          org-tag-alist '(("@work" . ?w) ("@home" . ?h)))
#+end_src

`org-outline-path-complete-in-steps` when set to nil allows selection
of the refile target using a single completion step, which will
provide a faster selection method if you have deeply nested
structures.
#+begin_src emacs-lisp
  (setq org-outline-path-complete-in-steps t)
#+end_src

When refiling target is GTD file we want to automatically save the
buffer.
#+begin_src emacs-lisp
  (defun hesam/org-refile-save (&rest _)
    "Save the buffer after refiling.

     This function checks if the current buffer is visiting 'gtd.org'.
     If so, it saves the buffer. It is used as an advice to `org-refile`,
     meaning it is called every time after `org-refile` is invoked."
    (when (eq (current-buffer) (find-buffer-visiting "gtd.org"))
      (save-buffer)))

  (advice-add 'org-refile :after 'hesam/org-refile-save)
#+end_src

Defines a toggler to show our GTD file whenever it is not visible in
the window and to hide it if it is.
#+begin_src emacs-lisp
  (defun gtd/toggle-doing ()
    "Access the GTD gtd.org file inside `gtd-directory'.
    The tasks in this file are actively working on. If the buffer
    is visible then delete it, else open it in another window."
    (interactive)
    (let ((buf (get-buffer "gtd.org")))
      (if (and buf (get-buffer-window buf))
          (delete-window (get-buffer-window buf))
        (find-file-other-window gtd-file))))
#+end_src

*** View
Start with current day and do not show tasks that are done.
#+begin_src emacs-lisp
  (setq org-agenda-start-on-weekday nil
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t
        org-agenda-show-all-dates t)
#+end_src

From emacs cafe [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][blog]] to get gtd context filtered in the dispatcher.
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(("w" "Context work" tags-todo "@work"
           ((org-agenda-overriding-header "Work")
            (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))
          ("h" "Context home" tags-todo "@home"
           ((org-agenda-overriding-header "Home")
            (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))))

  (defun my-org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))
#+end_src

And lastly to cleanup the Org agenda TODO view
#+begin_src emacs-lisp
(setq org-agenda-prefix-format
      '((agenda . " %i %-12:c%?-12t% s")
        (todo   . " ")
        (tags   . " %i %-12:c")
        (search . " %i %-12:c")))
#+end_src

*** Keybindings
For accessing Org agenda and GTD quickly.
#+begin_src emacs-lisp
  ;; capture to template Inbox "i" directly
  (keymap-global-set "C-c c" #'(lambda () (interactive) (org-capture nil "i")))

  ;; (leader-org-mode
  ;;   "a" 'org-agenda
  ;;   "c" 'org-capture
  ;;   "g" 'gtd/toggle-doing
  ;;   "l" 'org-store-link
  ;;   "x" 'org-archive-subtree)

  ;; (leader-org-mode
  ;;   :keymaps 'org-mode-map
  ;;   "r" 'org-refile)
#+end_src

*** Templates
Storage for Org capture is set to Dropbox to provide syncing between
devices.
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("i" "Inbox" entry
           (file gtd-file) "* %u %i%?")
          ("p" "Planned" entry
           (file+headline gtd-file "Planned") "* %t %i%?")))
#+end_src

** Appearance
We basically use org-modern for look and feel. But using
`org-modern-star` screws with navigation `C-n/p`. We therefore don't
use it. [[https://github.com/minad/org-modern/issues/134][See this Github issue]].
#+begin_src emacs-lisp
  (use-package org-modern
    :config (setq org-modern-star nil)
    :hook (org-mode . org-modern-mode))
#+end_src

So in order to get nice bullet points we use `org-bullets`.
#+begin_src emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))
#+end_src

Hook `visual-line-mode` to `org-mode`
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

** LaTeX
SRC blocks in latex should be syntax highlighted
#+begin_src emacs-lisp
  (setq org-latex-src-block-backend 'engraved)
#+end_src

* Programming settings
Programming related settings and packages defined here. Language
Server Protocol (LSP) provides IDE-like features and is configured
here. Some relevant minor modes also set here, including their look
and feel if appropriate. But first... let's get confgiurer tabs!
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 4)
#+end_src

** auto-mode
We associate some file extensions with major modes not included by default
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("Dockerfile" . dockerfile-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.y[a]?ml\\'" . yaml-ts-mode))
#+end_src

** eglot
Setup Language Server Protocol (LSP) for different programming
languages. We use eglot which is built-in >= Emacs 29.
#+begin_src emacs-lisp
  (use-package eglot
    :defer 1
    :config
    (setq eglot-sync-connect 1)
    (set-face-attribute 'eglot-highlight-symbol-face nil :inherit 'match)
    :bind (:map eglot-mode-map
                ("C-c e r" . eglot-rename)
                ("C-c e f" . eglot-format)
                ("C-c e d" . eglot-find-declaration)
                ("C-c e i" . eglot-find-implementation))
    :hook ((go-ts-mode python-ts-mode rust-ts-mode) . eglot-ensure))

  ;; (use-package eglot-booster
  ;;   :if (file-exists-p "~/.local/bin/emacs-lsp-booster")
  ;;   :defer 2
  ;;   :after eglot
  ;;   :config
  ;;   (eglot-booster-mode))
#+end_src

** envrc
Automatically loads `.envrc` files when visiting a directory.
#+begin_src emacs-lisp
  (use-package envrc
    :config
    (envrc-global-mode))
#+end_src
** flymake
Flymake is an built-in syntax checker for Emacs to be used everywhere,
but it's stronlgy linked to programming and that is why we define it
here.

Out of intereset here is the setting `flymake-no-changes-timeout`. If set to a number, then Flymake will check the file after waiting that number in seconds for each change you make in the buffer. Curiously, setting it to a high number helps with clearing out wrong error messages after we have saved the buffer. Hence, with our settings we only run flymake after save.
#+begin_src emacs-lisp
  (use-package flymake
    :config
    (setq flymake-no-changes-timeout 0.25
          flymake-proc-compilation-prevents-syntax-check t
          flymake-start-on-flymake-mode t
          flymake-start-on-save-buffer t
          flymake-suppress-zero-counters t
          flymake-wrap-around nil
          flymake-fringe-indicator-position 'left-fringe))
#+end_src

*** sideline
Shows flymake messages on the margin of choice.
#+begin_src emacs-lisp
  (use-package sideline-flymake
    :init
    (setq sideline-flymake-display-mode 'line
          sideline-backends-right '(sideline-flymake))
    :hook (flymake-mode . sideline-mode))
#+end_src

** git
*** Magit
git porcelain
#+begin_src emacs-lisp
  (use-package magit
    :bind ("C-c g" . magit-status)
    :init
    (advice-add #'project-vc-dir :override #'magit-project-status)
    (add-to-list 'display-buffer-alist
               '("magit"
                 (display-buffer-reuse-mode-window
                  display-buffer-in-direction)
                 (mode magit-mode)
                 (window . root)
                 (direction . right))))
#+end_src

** modes
Many of these mode are activated by adding a hook to `prog-mode-hook`
or is highly associated with programming.
*** ediff
Ediff is used for viewing diffs and acting upon them. We want the
control that normally displays in another frame to be place in the
same window.
#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

*** electric mode
Automatically add closing brackets and indent code in `prog-mode`.
#+begin_src emacs-lisp
  (defun hesam/electric ()
    (electric-pair-local-mode t)
    (electric-indent-local-mode t))
  (add-hook 'prog-mode-hook #'hesam/electric)
#+end_src

*** hideshow
Set up the `hideshow` minor mode for `prog-mode`.
#+begin_src emacs-lisp
  (setq hs-allow-nesting t)
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (eval-after-load 'prog-mode
    '(define-key prog-mode-map (kbd "C-<return>") 'hs-toggle-hiding))
#+end_src

Another symbol to be used for collapsed text.
#+begin_src emacs-lisp
  (set-display-table-slot standard-display-table
                          'selective-display (string-to-vector " [+] "))
#+end_src

*** row/column/line numbers
Shows column number in `mode-line` in addtion to row number.
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'column-number-mode)
#+end_src

*** show parent
Highlights matching parens in prog-mode.
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+end_src

** programming
*** Go
#+begin_src emacs-lisp
  (use-package go-ts-mode
    :defer 1
    :config
    (setq go-ts-mode-indent-offset 4))
#+end_src

*** Python
Python-specific settings and packages.
**** black
#+begin_src emacs-lisp
  (use-package python-black
    :hook (python-ts-mode . python-black-on-save-mode-enable-dwim))
#+end_src

**** pyenv
Use `pyvenv` to manage Python virtual environments.
#+begin_src emacs-lisp
  (use-package pyvenv)
#+end_src

*** Rust
Demand the new treesitter mode for Rust.
#+begin_src emacs-lisp
  (use-package rust-ts-mode
    :defer 1)
#+end_src

** treesit
*** auto
#+begin_src emacs-lisp
  (use-package treesit-auto
    :defer 2
    :config
    (setq treesit-auto-install t)
    (global-treesit-auto-mode))
#+end_src

*** remap
#+begin_src emacs-lisp
  (setq major-mode-remap-alist
        '((bash-mode . bash-ts-mode)
          (css-mode . css-ts-mode)
          (js2-mode . js-ts-mode)
          (json-mode . json-ts-mode)
          (python-mode . python-ts-mode)
          (rust-mode . rust-ts-mode)
          (typescript-mode . typescript-ts-mode)
          (yaml-mode . yaml-ts-mode)))
#+end_src
** vundo
In this excellet [[https://archive.casouri.cc/note/2021/visual-undo-tree/index.html][blog]] Yuan Fu describes a way of creating an undo-tree
from Emacs' linear tree. This enables us to build an undo-tree on the
fly, navigate it and make Emacs go to that state. Born is the package
`vundo` (visualize undo).
#+begin_src emacs-lisp
  (use-package vundo)
#+end_src

** ws-butler
Removes trailing space and tabs from this user modified lines.
#+begin_src emacs-lisp
  (use-package ws-butler
    :hook ((prog-mode text-mode) . ws-butler-mode))
#+end_src

* Search settings
Settings for searching buffers, notes and more.
** consult
#+begin_src emacs-lisp
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element
    :init
    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    :config
    (setq consult-narrow-key "<"))




#+end_src

** deft
deft is a roam-like utility for quickly creating notes and searching
for them.
#+begin_src emacs-lisp
  (use-package deft
    :commands (deft)
    :config  (setq deft-file-naming-rules	;; use dots as delimiters in filename and downcase
                   '((noslash . ".")
                     (nospace . ".")
                     (case-fn . downcase))
                   deft-use-filename-as-title nil
                   deft-use-filter-string-for-filename t
                   deft-extensions '("org")
                   deft-default-extension "org"))
#+end_src
*** director
Chooses which directory to run deft in. Courtesy of [[http://pragmaticemacs.com/category/deft/][bjm]].
#+begin_src emacs-lisp
  (defun hesam/deft-director (dir)
    "Run deft in directory DIR"
    (setq deft-directory dir)
    (switch-to-buffer "*Deft*")
    (kill-this-buffer)
    (deft))
#+end_src
*** projects
We define different projects under a common deft directory.
#+begin_src emacs-lisp
  (defcustom hesam-deft-directory "~/Dropbox/org/deft"
    "Directory for Deft notes in Hesam's Emacs configuration."
    :type 'directory
    :group 'hesam)
#+end_src

Now we declare projects which invokes the director with the root to
that project.
#+begin_src emacs-lisp
  (defun hesam/recipes ()
    "Open the recipes project for searching and taking cooking-related notes.
  This function uses hesam/deft-director to open the recipes project directory."
    (interactive)
    (hesam/deft-director (concat hesam-deft-directory "/recipes")))

  (defun hesam/notes ()
    "Open the notes project for general note-taking.
  This function uses hesam/deft-director to open the notes project directory."
    (interactive)
    (hesam/deft-director (concat hesam-deft-directory "/notes")))
#+end_src

*** Keybindings
** Regexp is default search
#+begin_src emacs-lisp
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
#+end_src

* Shell settings
Shell related packages and configurations. Our main emulator is
vterm. In order to get all environment variables correctly we define
them in `.bash_profile`, let the package `exec-path-from-shell` read
them and intialize our terminal correctly.

** Options
Use completions other than for binaries.
#+begin_src emacs-lisp
  (setq shell-completion-execonly nil)
#+end_src

** exec-path-from-shell
Uses environment variables defined in your env files
correctly. Otherwise, we have executables that are not reconginzed by
Emacs shells.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+end_src

** vterm
Powerful terminal emulator based on libvterm written in C. Fast,
colorful a delight.
#+begin_src emacs-lisp
  (use-package vterm
    :after project
    :init
    (if (eq system-type 'darwin)
        (setq vterm-shell "/bin/zsh"))
    (add-to-list 'project-switch-commands '(hesam/vterm-project-shell "vterm" ?s))
    (advice-add #'project-shell :override #'hesam/vterm-project-shell)
    (add-to-list 'display-buffer-alist
                 '(".* vterm\\*"           ; captures vterm in project
                   (display-buffer-in-direction)
                   (direction . below)
                   (dedicated . t)
                   (window . root)
                   (window-height . 0.25)
                   (inhibit-same-window . nil)))
    (add-to-list 'display-buffer-alist
                 '("\\*vterm.*"           ; regular vterm
                   (display-buffer-in-direction)
                   (direction . below)
                   (window . root)
                   (inhibit-same-window . nil)))
    :custom
    (vterm-max-scrollback 10000))
#+end_src

The custom function `hesam/vterm-project-shell` is for usage with
`project.el`. It overrides the default shell. The function is rather
long because we want to make sure vterm is started in `project-root`
and have requirements on how and when a new window is created.
#+begin_src emacs-lisp
  (defun hesam/vterm-project-shell ()
    "Run `vterm' in the current project's root.

  If the VTerm buffer for this project exists and is visible, switch to it.
  If it exists but is not visible, pop a new window and switch to it.
  If the buffer does not exist, create a new one and switch to it.
  A numeric prefix argument ARG does two things:
  - If a buffer associated with the prefix exists, switch to that buffer accordingly.
  - Otherwise, create a new buffer with the prefix number in the name."
    (interactive)
    (if (fboundp 'project-root)
        (let* ((root (project-root (project-current t)))
               (dir-name (file-name-nondirectory (directory-file-name root)))
               (prefix-arg (if current-prefix-arg (format "<%d>"current-prefix-arg) ""))
               (buffer-name (format "*%s*%s" (concat dir-name " vterm") prefix-arg))
               (existing-buffer (get-buffer buffer-name)))
          (if existing-buffer
              (pop-to-buffer existing-buffer)
            (let ((new-buffer (vterm-other-window buffer-name)))
              (with-current-buffer new-buffer
                (vterm-send-string (concat "cd " root))
                (vterm-send-return)
                (vterm-send-C-l)))))))
#+end_src

* UI Enhancement settings
Settings for the feel and look of Emacs. We may also have some options
configured elsewhere which affects the look of Emacs. One such example
is the face `hideshow` minor mode uses, which we have put in
`programming.org` because it's directly related to programming.

** Fonts
*** Family
The core of our text rendering in Emacs, the font family, is defined
here as a configurable variable, which ensures flexibility and
customization.
#+begin_src emacs-lisp
  (defcustom hesam-default-font-family "IosevkaTerm SS05"
    "Default font family."
    :type 'string
    :group 'hesam)
#+end_src

*** Resolution-specific font sizes
To maintain a visually pleasing font size regardless of the display
resolution, we define custom variables that set the font height based
on whether the screen is high-resolution (HiRes) or low-resolution
(LowRes). The variables `hesam-hires-display-font-height` and
`hesam-lowres-display-font-height` control the font height values for
HiRes and LowRes displays, respectively.
#+begin_src emacs-lisp
  (defvar hesam-hires-display-font-height-value 180
    "The actual value of 'hesam-hires-display-font-height'.")

  (defvar hesam-lowres-display-font-height-value 120
    "The actual value of 'hesam-lowres-display-font-height'.")

  (defcustom hesam-modeline-hires-height (floor (* hesam-hires-display-font-height-value 0.9))
    "Modeline high-resolution height."
    :type 'integer
    :group 'hesam)

  (defcustom hesam-modeline-lowres-height (floor (* hesam-lowres-display-font-height-value 0.9))
    "Modeline low-resolution height."
    :type 'integer
    :group 'hesam)
#+end_src

*** Default font attributes
We explicitly set the attributes for the `'default`, `'fixed-pitch`,
and `'variable-pitch` fonts. These attributes include the font family,
weight, and height, the latter depending on the screen resolution.
#+begin_src emacs-lisp
  (set-face-attribute 'default nil
                      :family hesam-default-font-family
                      :weight 'regular
                      :height hesam-lowres-display-font-height-value)

  (set-face-attribute 'fixed-pitch nil
                      :inherit 'default)

  (set-face-attribute 'fixed-pitch-serif nil
                      :inherit 'default)

  ;; we need to set it expclitly otherwise Emacs will display with
  ;; this face with another font, see the start screen as an example
  (set-face-attribute 'variable-pitch nil
                      :family hesam-default-font-family
                      :inherit 'default)
#+end_src

*** Font size adjustment functions
In scenarios where an Emacs frame is dragged between screens of
different resolutions, all font sizes within that frame must be
updated accordingly. The function `hesam/font-per-display` is designed
to handle this, and it's set to run every time a new frame is created
or moved.
**** Threshold
The variable `hesam-hires-resolution-threshold` sets the resolution
threshold for high-resolution displays.
#+begin_src emacs-lisp
  (defvar hesam-hires-resolution-threshold-value 1200
    "The actual value of 'hesam-hires-resolution-threshold'.")
#+end_src

**** Functions
The functions `hesam/font-per-display` and `hesam/set-font-sizes` work
in tandem to adjust the font sizes based on the current screen
resolution.
#+begin_src emacs-lisp
  (defun hesam/font-per-display (frame)
    "Adjust the font size based on the FRAME's resolution."
    (let* ((geometry (frame-monitor-attribute 'geometry frame))
           (resolution (car (last geometry))))
      (select-frame frame)
      (if (> resolution hesam-hires-resolution-threshold-value)
          (hesam/set-font-sizes frame hesam-hires-display-font-height-value hesam-modeline-hires-height)
        (hesam/set-font-sizes frame hesam-lowres-display-font-height-value hesam-modeline-lowres-height))))

  (defun hesam/set-font-sizes (frame default-height modeline-height)
    "Helper function to set the font sizes of FRAME."
    (set-face-attribute 'default frame :height default-height)
    (set-face-attribute 'mode-line frame :height modeline-height)
    (set-face-attribute 'mode-line-inactive frame :height modeline-height))
#+end_src

**** Custom variables
The following custom variables control the font height based on the
screen resolution. The `:set` attribute in each `defcustom` call is
used to automatically update the font sizes using the
`hesam/font-per-display` function whenever these variables are
changed.
#+begin_src emacs-lisp
  (defcustom hesam-hires-display-font-height 180
    "Font height for high-resolution displays."
    :type 'integer
    :group 'hesam
    :set (lambda (sym value)
           (set-default sym value)
           (setq hesam-hires-display-font-height-value value)
           (hesam/font-per-display (selected-frame)))
    :get (lambda (sym) hesam-hires-display-font-height-value))

  (defcustom hesam-lowres-display-font-height 120
    "Font height for low-resolution displays."
    :type 'integer
    :group 'hesam
    :set (lambda (sym value)
           (set-default sym value)
           (setq hesam-lowres-display-font-height-value value)
           (hesam/font-per-display (selected-frame)))
    :get (lambda (sym) hesam-lowres-display-font-height-value))

  (defcustom hesam-hires-resolution-threshold 1200
    "Resolution threshold for high-resolution displays."
    :type 'integer
    :group 'hesam
    :set (lambda (sym value)
           (set-default sym value)
           (setq hesam-hires-resolution-threshold-value value)
           (hesam/font-per-display (selected-frame)))
    :get (lambda (sym) hesam-hires-resolution-threshold-value))
#+end_src
**** Hooks
Hooks are set up to ensure `hesam/font-per-display` is executed as
required, maintaining optimal font size regardless of the screen
resolution. This ensures that the font sizes are adjusted
automatically when we create a new frame or move an existing frame to
another screen.
#+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions 'hesam/font-per-display)
  (add-hook 'move-frame-functions 'hesam/font-per-display)
#+end_src

*** Ligatures
Ligatures are a way to display multiple characters as a single glyph. Here we use the package `ligature` to enable ligatures in Emacs. We use the font Iosevka Term Font which has ligatures built-in. We also set the ligatures to be enabled in programming modes.
#+begin_src emacs-lisp
  (use-package ligature
    :config
    (ligature-set-ligatures
     'prog-mode
     '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->"
       "<--->" "<---->" "<!--" "<==" "<===" "<=" "=>" "=>>"
       "==>" "===>" ">=" "<=>" "<==>" "<===>" "<====>" "<!---"
       "<~~" "<~" "~>" "~~>" "::" ":::" "==" "!=" "===" "!=="
       ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>" "+:"
       "-:" "=:" "<******>" "++" "+++"))
    :hook (prog-mode . ligature-mode))
#+end_src

** Themes
*** Ef
#+begin_src emacs-lisp
  (use-package ef-themes
    :config
    (setq ef-themes-common-palette-overrides
          '((builtin fg-main)
            (constant fg-main)
            (identifier fg-main)
            (preprocessor fg-main)
            (prompt fg-main)
            (variable fg-main))))
#+end_src

*** Modus
#+begin_src emacs-lisp
  (use-package modus-themes
    :config
    (setq modus-themes-bold-constructs t))
#+end_src

*** Tok
#+begin_src emacs-lisp
  (use-package tok-theme)
#+end_src

** Cursor
No blinking cursor!
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

** Frame customization and decorations
Lastly we use a little margin on both sides. Mainly because we want
some padding between buffers. Recall that `internal-border` option is
only around the frame and does not apply in areas that do not touch a
frame edge.
#+begin_src emacs-lisp
  (setq-default right-margin-width 1)
#+end_src

Do not truncate lines and if we need it the default binding to toggle
is `C-x x t`. A value of `t` means to NOT truncate lines.
#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

Setting partial width windows to `nil` means to respect the value for
`truncate-lines`, otherwise we will get truncated lines for
horizontally split windows (ie. `C-x 3` windows).
#+begin_src emacs-lisp
  (setq-default truncate-partial-width-windows nil)
#+end_src

Set fringes to be invisible by inheriting from 'default. Hook it so it
updates when changing themes.
#+begin_src emacs-lisp
  (add-hook
   'after-load-theme-hook
   (lambda (&optional args) (set-face-attribute 'fringe nil :background 'unspecified)))
#+end_src

** Mode-line
We like a compact mode-line and since VC mode will display potentially
long branch names we remove it from the mode-line. To be safe we
remove it after startup to ensure it is set when we try and delete it.
#+begin_src emacs-lisp
  (setq mode-line-compact t)
  (add-hook
   'emacs-startup-hook
   (lambda ()
     (delete '(vc-mode vc-mode) mode-line-format)))
#+end_src

and to remove the precentage and All/Top/Bottom indicator.
#+begin_src emacs-lisp
  (setq mode-line-percent-position nil)
#+end_src

Remove global info from the mode-line. Otherwise `display-time-mode`
will display the time on every mode-line bar since
`mode-line-misc-info` carries the global-string. We instead opt for
the tab-bar to include the global-info-string since for each frame we
have only one tab-bar. At the time of writing, as you'll see below, we
need to wait until the mode-line-misc-info is set and safest is to do
it after startup.
#+begin_src emacs-lisp
  (add-hook
   'emacs-startup-hook
   (lambda ()
     (delete '(global-mode-string ("" global-mode-string)) mode-line-misc-info)))
#+end_src

To further clean-up the mode-line we will install `minions` that hides
them under the major mode. Now all relevant minor modes are shown
under a hidden list.
#+begin_src emacs-lisp
  (use-package minions
    :defer 1
    :config (minions-mode t))
#+end_src

** Tabs and Windows
Start with configuring the behavior and look of the tab bar, for
example we enable the functionality and hide the close tab button.
#+begin_src emacs-lisp
  (setq tab-bar-mode t
        tab-bar-show 1
        tab-bar-close-button-show nil
        tab-bar-auto-width nil)
#+end_src

Sets the look of tab bar. We choose =not= to extenuate it and let it
melt with the 'default background. However, we make sure to have a
divider -- using `:underline` to highlight where the tab-bar starts.
#+begin_src emacs-lisp
  (defun hesam/set-tab-face-attributes ()
    "Set the face attributes for the tab-bar and its tabs.

    This function achieves the following:
    1. Configures the default appearance of the tab-bar to match the default
       face's foreground and background, with adjustments for height, font
       family, weight, and underlining.
    2. Differentiates between active and inactive tabs by setting distinct
       face attributes. Active tabs have a more pronounced appearance
       with an ultra-bold weight, while inactive tabs are lighter.

    Prerequisites:
    - Requires the default face's foreground and background to be set.
    - Relies on the `hesam-default-font-family` variable for font specification.

    Note: The function should be invoked after any theme or face customizations
    to ensure consistency with the default face attributes."
    (when (and (face-foreground 'default) (face-background 'default))
        (set-face-attribute 'tab-bar nil
                        :height 0.95
                        :family hesam-default-font-family
                        :weight 'normal
                        :foreground (face-foreground 'default)
                        :background (face-background 'default)
                        :underline (face-foreground 'default)
                        :box nil)

    ;; To differentiate between active/inactive tabs we make adjustments
    ;; to the text weight.
    (set-face-attribute 'tab-bar-tab nil
                        :inherit 'tab-bar
                        :weight 'ultra-bold
                        :underline (face-foreground 'default)
                        :background (face-background 'default)
                        :box `(:line-width (1 . 10) :color ,(face-background 'default) :style nil))

    (set-face-attribute 'tab-bar-tab-inactive nil
                        :inherit 'tab-bar
                        :weight 'light
                        :background (face-background 'default)
                        :box `(:line-width (1 . 10) :color ,(face-background 'default) :style nil))))

  ;; Run the function to set the look after init is complete
  (add-hook
   'emacs-startup-hook
   'hesam/set-tab-face-attributes)

  ;; And add it as a hook to adhere with changes when switching theme
  ;; during run-time.
  (add-hook
   'after-load-theme-hook
   (lambda (&optional theme) (hesam/set-tab-face-attributes)))
#+end_src

Next we decide what to display in the tab bar. This is done by adding
functions to a variable that does something in the tab bar (like
returning a string). The `tab-bar-format-global` option will display
info that are of _global_ nature, such as the time with
`display-time-mode`.
#+begin_src emacs-lisp
  (setq tab-bar-format
        '(tab-bar-format-tabs
          tab-bar-separator
          tab-bar-format-align-right
          tab-bar-format-global))
#+end_src

However, the tab bar format tabs string prepends a separator on the
very left side. We'll remove it.
#+begin_src emacs-lisp
  (advice-add
   'tab-bar-format-tabs :around (lambda (orig-fun) (cdr (funcall orig-fun))))
#+end_src

Next we want all tabs to be displayed in UPCASE. The function that
automatically names tabs is `tab-bar-tab-name-current` which we
decorate.
#+begin_src emacs-lisp
  (defun hesam/uppercase-tab-name-current (original-function &rest args)
    (upcase (apply original-function args)))
  (advice-add 'tab-bar-tab-name-current :around #'hesam/uppercase-tab-name-current)
#+end_src

And to quickly switch between tabs we bind convenient keys
#+begin_src emacs-lisp
  (global-set-key (kbd "s-n") 'tab-next)
  (global-set-key (kbd "s-p") 'tab-previous)
#+end_src

We want to repeat closing tabs. Hence we insert it in the repeat-map
table.
#+begin_src emacs-lisp
  (defvar tab-close-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "0") #'tab-close)
      map))
  (put 'tab-close 'repeat-map 'tab-close-repeat-map)
#+end_src

Define a function that kills all buffers associated with a window
#+begin_src emacs-lisp
  (defun hesam/close-window-and-buffers ()
    "Kill all buffers associated with the current window, and then delete the window if possible."
    (interactive)
    (let* ((current-window (selected-window))
           (buffers (delq nil (mapcar (lambda (win)
                                        (when (eq win current-window)
                                          (window-buffer win)))
                                      (window-list)))))
      (mapc 'kill-buffer buffers)
      (unless (one-window-p t)
        (delete-window current-window))))
#+end_src

and build upon that to close the tab as well, bind this `C-x t k`.
#+begin_src emacs-lisp
  (defun hesam/kill-buffer-on-close-tab ()
    (interactive)
    (hesam/close-window-and-buffers)
    (tab-close))

  ;; Usually we don't bind custom keys to C-x but make an exception this
  ;; time to gather all tab commands with the one defined.
  (global-set-key (kbd "C-x t k") 'hesam/kill-buffer-on-close-tab)
#+end_src

But sometimes we just want to kill next window in cyclic order and to
do that we make use of `other-window` function.
#+begin_src emacs-lisp
  (defun hesam/switch-and-close-next-window ()
    "Switch to the next window in cyclic order, then kill the window."
    (interactive)
    (other-window 1)
    (delete-window))
#+end_src

Enable `winner-mode` everywhere which will allow undo and redo for
tabs and windows. Windmove allows for easy navigation inside a
window. We configure windmove to wrap around when moving buffers
around (windmove is enabled by default).
#+begin_src emacs-lisp
  (winner-mode t)
  (setq windmove-wrap-around t)
#+end_src

Under prefix `C-c w` we define keybindings for windmov's display
feature and winner mode. We are inspired by Vim bindings to allow for
fast display of next buffers. Winner mode is naturally bound to `u`
and `r`.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c w k") 'windmove-display-up)
  (global-set-key (kbd "C-c w j") 'windmove-display-down)
  (global-set-key (kbd "C-c w h") 'windmove-display-left)
  (global-set-key (kbd "C-c w l") 'windmove-display-right)
  (global-set-key (kbd "C-c w s") 'windmove-display-same-window)
  (global-set-key (kbd "C-c w r") 'winner-redo)
  (global-set-key (kbd "C-c w u") 'winner-undo)

#+end_src

Here we bind convenient bindings for easy traversal between buffers in
a window. Additionally we define keys for swapping buffer locations.
#+begin_src emacs-lisp
  ;; Define windmove keybindings
  (global-set-key (kbd "s-k") 'windmove-up)
  (global-set-key (kbd "s-j") 'windmove-down)
  (global-set-key (kbd "s-h") 'windmove-left)
  (global-set-key (kbd "s-l") 'windmove-right)

  ;; Define windmove-swap-states keybindings
  (global-set-key (kbd "s-K") 'windmove-swap-states-up)
  (global-set-key (kbd "s-J") 'windmove-swap-states-down)
  (global-set-key (kbd "s-H") 'windmove-swap-states-left)
  (global-set-key (kbd "s-L") 'windmove-swap-states-right)
#+end_src

** Marginalia
This package displays helpful descriptions of on the margins in
certains instances. For example: invoking `M-x` displays all commands
that can be called interactively. `Marginalia` will show their
descriptions on the right hand side -- at the margin if you will.
#+begin_src emacs-lisp
  (use-package marginalia
    :defer 2
    :config
    (marginalia-mode))
#+end_src

** Which-key
Displays available key chords after partially input. Hence, if we
input `C-x t` to Emacs then `which-key` will display all defined key
chords that are prefixed with `C-x t`. Placement of which-key window
is on the bottom and pagination is done by `C-h n` for next and `C-h
p` for previous.
#+begin_src emacs-lisp
  (use-package which-key
    :defer 2
    :config
    (which-key-mode t)
    (which-key-setup-side-window-bottom))
#+end_src
