#+TITLE: UI Enhancements
#+STARTUP: OVERVIEW
* Introduction
Settings for the feel and look of Emacs. We may also have some options
configured elsewhere which affects the look of Emacs. One such example
is the face `hideshow` minor mode uses, which we have put in
`programming.org` because it's directly related to programming.

* Themes
** Dracula
The name of the theme is `dracula` -- dark, sleek and ubiquitous with
lots of color!
#+BEGIN_SRC emacs-lisp
  (use-package dracula-theme
    :init
    (setq dracula-enlarge-headings nil)
    :config
    (load-theme 'dracula t)
    :init
    (add-hook
     'after-load-theme-hook
     (lambda (theme)
       (when (eq theme 'dracula)
         ;; We don't like the match face provided by Dracula so we change it
         ;; here -- as this should only be done if this theme is used.
         (set-face-attribute 'match nil :background "#bd93f9")

         ;; Use Dracula theme colors for the tab bar; we prefer it to be slighly
         ;; smaller than surrounding text. We'll also add a line across the Emacs
         ;; frame to separate the tab bar from the buffer. Inheriting nil to make
         ;; sure it does not get values from `'default` which would alter size of
         ;; tab bar font when zooming in/out the buffer.
         (set-face-attribute 'tab-bar nil
                             :height 0.95
                             :family hesam-default-font-family
                             :weight 'regular
                             :foreground "#f8f8f2"
                             :background "#282a36"
                             :underline "#44475a"
                             :box nil)

         ;; To differentiate between active/inactive tabs we make adjustments
         ;; to the text weight and colors.
         (set-face-attribute 'tab-bar-tab nil
                             :inherit 'tab-bar
                             :weight 'bold
                             :foreground "#ff79c6"
                             :background "#282a36"
                             :underline "#ff79c6"
                             :box `(:line-width (1 . 10) :color "#282a36" :style nil))

         (set-face-attribute 'tab-bar-tab-inactive nil
                             :inherit 'tab-bar
                             :foreground "#bd93f9"
                             :background "#282a36"
                             :box `(:line-width (1 . 10) :color "#282a36" :style nil))
         ;; Hides the fringe on vertical edges of the screen
         (set-face-attribute 'fringe nil
                             :background "#282a36")))))
#+END_SRC

** Modus
#+BEGIN_SRC emacs-lisp
  (use-package modus-themes
    :init
    (add-hook
     'after-load-theme-hook
     (lambda (theme)
       (when (string-match-p "modus-" (symbol-name theme))
         ;; Theme bar set to background with a window divider (underline)
         (set-face-attribute 'tab-bar nil
                             :height 0.95
                             :family hesam-default-font-family
                             :foreground (modus-themes-get-color-value 'bg-main)
                             :background (modus-themes-get-color-value 'bg-main)
                             :underline (modus-themes-get-color-value 'border)
                             :box nil)

         ;; To differentiate between active/inactive tabs we make adjustments
         ;; to the text weight and colors.
         (set-face-attribute 'tab-bar-tab nil
                             :inherit 'tab-bar
                             :weight 'bold
                             :foreground (modus-themes-get-color-value 'red)
                             :background (modus-themes-get-color-value 'bg-main)
                             :underline (modus-themes-get-color-value 'red)
                             :box `(:line-width (1 . 10) :color ,(modus-themes-get-color-value 'bg-main) :style nil))

         (set-face-attribute 'tab-bar-tab-inactive nil
                             :inherit 'tab-bar
                             :background (modus-themes-get-color-value 'bg-main)
                             :foreground (modus-themes-get-color-value 'fg-main)
                             :box `(:line-width (1 . 10) :color ,(modus-themes-get-color-value 'bg-main) :style nil))

         ;; Hides the fringe on vertical edges of the screen
         (set-face-attribute 'fringe nil
                             :background (modus-themes-get-color-value 'bg-main))))))
#+END_SRC

** Ef
#+BEGIN_SRC emacs-lisp
  (use-package ef-themes
    :init
    (add-hook
     'after-load-theme-hook
     (lambda (theme)
       (when (string-match-p "ef-" (symbol-name theme))
         ;; Theme bar set to background with a window divider (underline)
         (set-face-attribute 'tab-bar nil
                             :height 0.95
                             :family hesam-default-font-family
                             :foreground (ef-themes-get-color-value 'bg-main)
                             :background (ef-themes-get-color-value 'bg-main)
                             :underline (ef-themes-get-color-value 'border)
                             :box nil)

         ;; To differentiate between active/inactive tabs we make adjustments
         ;; to the text weight and colors.
         (set-face-attribute 'tab-bar-tab nil
                             :inherit 'tab-bar
                             :weight 'bold
                             :foreground (ef-themes-get-color-value 'red)
                             :background (ef-themes-get-color-value 'bg-main)
                             :underline (ef-themes-get-color-value 'red)
                             :box `(:line-width (1 . 10) :color ,(ef-themes-get-color-value 'bg-main) :style nil))

         (set-face-attribute 'tab-bar-tab-inactive nil
                             :inherit 'tab-bar
                             :background (ef-themes-get-color-value 'bg-main)
                             :foreground (ef-themes-get-color-value 'fg-main)
                             :box `(:line-width (1 . 10) :color ,(ef-themes-get-color-value 'bg-main) :style nil))

         ;; Hides the fringe on vertical edges of the screen
         (set-face-attribute 'fringe nil
                             :background (ef-themes-get-color-value 'bg-main))))))
#+END_SRC

* Cursor
We always want the cursor to always blink so we can easily find it.
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode t)
  (setq blink-cursor-blinks 0) ;; blink forever
#+END_SRC

Highlights current line in programming buffers, ie. in `prog-mode`
activated buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC

* Fonts
We set the default, fixed-pitch and variable-pitch fonts here.  In
order to get good font size across different screens we define
variables that depend on resolutions, high-res and low-res.
#+BEGIN_SRC emacs-lisp
  (defcustom hesam-default-font-family "IosevkaTerm Nerd Font"
    "Default font family."
    :type 'string
    :group 'hesam)

  (defcustom hesam-default-hires-height 180
    "Default high-resolution height."
    :type 'integer
    :group 'hesam)

  (defcustom hesam-default-lowres-height 120
    "Default low-resolution height."
    :type 'integer
    :group 'hesam)

  (defcustom hesam-modeline-hires-height (- hesam-default-hires-height 10)
    "Modeline high-resolution height."
    :type 'integer
    :group 'hesam)

  (defcustom hesam-modeline-lowres-height (- hesam-default-lowres-height 5)
    "Modeline low-resolution height."
    :type 'integer
    :group 'hesam)

  (set-face-attribute 'default nil
                      :family hesam-default-font-family
                      :weight 'regular
                      :height hesam-default-lowres-height)

  (set-face-attribute 'fixed-pitch nil
                      :inherit 'default)

  (set-face-attribute 'fixed-pitch-serif nil
                      :inherit 'default)

  ;; we need to set it expclitly otherwise Emacs will display with
  ;; this face with another font, see the start screen as an example
  (set-face-attribute 'variable-pitch nil
                      :family hesam-default-font-family
                      :inherit 'default)
#+END_SRC

If we drag an Emacs frame between screens with different resolutions
we have to update all font sizes in that frame. The
`hesam/font-per-display` achieves that and we let it be run each time
a new frame is created and whenever it's moved.
#+BEGIN_SRC emacs-lisp
  (defun hesam/font-per-display (frame)
    "Adjust the font size based on the FRAME's resolution."
    (let* ((geometry (frame-monitor-attribute 'geometry frame))
           (resolution (car (last geometry))))
      (select-frame frame)
      (if (> resolution 1200)
          (hesam/set-font-sizes frame hesam-default-hires-height hesam-modeline-hires-height)
        (hesam/set-font-sizes frame hesam-default-lowres-height hesam-modeline-lowres-height))))

  (defun hesam/set-font-sizes (frame default-height modeline-height)
    "Helper function to set the font sizes of FRAME."
    (set-face-attribute 'default frame :height default-height)
    (set-face-attribute 'mode-line frame :height modeline-height)
    (set-face-attribute 'mode-line-inactive frame :height modeline-height))

  (add-hook 'after-make-frame-functions 'hesam/font-per-display)
  (add-hook 'move-frame-functions 'hesam/font-per-display)
#+END_SRC

* Frame customization and decorations
Remove the menu, scroll and toolbar from Emacs frame.
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
#+END_SRC
Use an undecorated frame to remove OS titlebar. We also add internal
border around the whole Emacs frame which pads the frame from all
sides.

The `drag-internal` settings is for using the mouse to drag/resize the
Emacs frame, useful for when we have an undecorated frame.
#+BEGIN_SRC emacs-lisp
  (dolist (frame-option
           '((undecorated . t) (internal-border-width . 10) (drag-internal-border . 1)))
    (add-to-list 'default-frame-alist frame-option))
#+END_SRC

Lastly we use a little margin on both sides. Mainly because we want
some padding between buffers. Recall that `internal-border` option is
only around the frame and does not apply in areas that do not touch a
frame edge.
#+BEGIN_SRC emacs-lisp
  (setq-default right-margin-width 1)
#+END_SRC

Do not truncate lines and if we need it the default binding to toggle
is `C-x x t`. A value of `t` means to NOT truncate lines.
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

Setting partial width windows to `nil` means to respect the value for
`truncate-lines`, otherwise we will get truncated lines for
horizontally split windows (ie. `C-x 3` windows).
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-partial-width-windows nil)
#+END_SRC

* Mode-line
We like a compact mode-line and since VC mode will display potentially
long branch names we remove it from the mode-line.
#+BEGIN_SRC emacs-lisp
  (setq mode-line-compact t)
  (delete '(vc-mode vc-mode) mode-line-format)
#+END_SRC

and to remove the precentage and All/Top/Bottom indicator
#+BEGIN_SRC emacs-lisp
  (setq mode-line-percent-position nil)
#+END_SRC

To further clean-up the mode-line we will install `minions` that hides
them under the major mode. Now all relevant minor modes are shown
under a hidden list.
#+BEGIN_SRC emacs-lisp
  (use-package minions
    :config (minions-mode 1))
#+END_SRC

* Tabs and Windows
Start with configuring the behavior and look of the tab bar, for
example we enable the functionality and hide the close tab button.
#+BEGIN_SRC emacs-lisp
  (setq tab-bar-mode t
        tab-bar-close-button-show nil)
#+END_SRC

Next we decide what to display in the tab bar. This is done by adding
functions to a variable that does something in the tab bar (like
returning a string).
#+BEGIN_SRC emacs-lisp
  (setq tab-bar-format
        '(tab-bar-format-tabs         ; show tabs in the bar
          tab-bar-separator
          tab-bar-format-align-right)) ; render the bar across the frame
#+END_SRC

However, the tab bar format tabs string prepends a separator on the
very left side. We'll remove it.
#+BEGIN_SRC emacs-lisp
  (advice-add
   'tab-bar-format-tabs :around (lambda (orig-fun) (cdr (funcall orig-fun))))
#+END_SRC

Next we want all tabs to be displayed in UPCASE. The function that
automatically names tabs is `tab-bar-tab-name-current` which we
decorate.
#+BEGIN_SRC emacs-lisp
  (defun hesam/uppercase-tab-name-current (original-function &rest args)
    (upcase (apply original-function args)))
  (advice-add 'tab-bar-tab-name-current :around #'hesam/uppercase-tab-name-current)
#+END_SRC

And to quickly switch between tabs we bind convenient keys
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "s-n" 'tab-next
   "s-p" 'tab-previous)
#+END_SRC

We want to repeat closing tabs. Hence we insert it in the repeat-map
table.
#+BEGIN_SRC emacs-lisp
  (defvar tab-close-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "0") #'tab-close)
      map))
  (put 'tab-close 'repeat-map 'tab-close-repeat-map)
#+END_SRC

Define a function that kills all buffers associated with a window
#+BEGIN_SRC emacs-lisp
  (defun hesam/close-window-and-buffers ()
    "Kill all buffers associated with the current window, and then delete the window if possible."
    (interactive)
    (let* ((current-window (selected-window))
           (buffers (delq nil (mapcar (lambda (win)
                                        (when (eq win current-window)
                                          (window-buffer win)))
                                      (window-list)))))
      (mapc 'kill-buffer buffers)
      (unless (one-window-p t)
        (delete-window current-window))))
#+END_SRC

and build upon that to close the tab as well, bind this `C-x t k`.
#+BEGIN_SRC emacs-lisp
  (defun hesam/kill-buffer-on-close-tab ()
    (interactive)
    (hesam/close-window-and-buffers)
    (tab-close))

  ;; Usually we don't bind custom keys to C-x but make an exception this
  ;; time to gather all tab commands with the one defined.
  (general-define-key
   "C-x t k" 'hesam/kill-buffer-on-close-tab)
#+END_SRC

But sometimes we just want to kill next window in cyclic order and to
do that we make use of `other-window` function.
#+BEGIN_SRC emacs-lisp
  (defun hesam/switch-and-close-next-window ()
    "Switch to the next window in cyclic order, then kill the window."
    (interactive)
    (other-window 1)
    (delete-window))

  (leader-window
    "0" 'hesam/switch-and-close-next-window)
#+END_SRC

Enable `winner-mode` everywhere which will allow undo and redo for
tabs and windows. Windmove allows for easy navigation inside a
window. We configure windmove to wrap around when moving buffers
around (windmove is enabled by default).
#+BEGIN_SRC emacs-lisp
  (winner-mode t)
  (setq windmove-wrap-around t)
#+END_SRC

Under prefix `C-c w` we define keybindings for windmov's display
feature and winner mode. We are inspired by Vim bindings to allow for
fast display of next buffers. Winner mode is naturally bound to `u`
and `r`.
#+BEGIN_SRC emacs-lisp
  (leader-window
     "k" 'windmove-display-up
     "j" 'windmove-display-down
     "h" 'windmove-display-left
     "l" 'windmove-display-right
     "s" 'windmove-display-same-window
     "r" 'winner-redo
     "u" 'winner-undo)
#+END_SRC

Sometimes we have two windows in a frame and want to change
orientation from
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :config
    (leader-window
      "f" 'transpose-frame))
#+END_SRC

Here we bind convenient bindings for easy traversal between buffers in
a window. Additionally we define keys for swapping buffer locations.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "s-k" 'windmove-up
   "s-j" 'windmove-down
   "s-h" 'windmove-left
   "s-l" 'windmove-right

   "s-K" 'windmove-swap-states-up
   "s-J" 'windmove-swap-states-down
   "s-H" 'windmove-swap-states-left
   "s-L" 'windmove-swap-states-right)
#+END_SRC

* Marginalia
This package displays helpful descriptions of on the margins in
certains instances. For example: invoking `M-x` displays all commands
that can be called interactively. `Marginalia` will show their
descriptions on the right hand side -- at the margin if you will.
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode))
#+END_SRC

* Which-key
Displays available key chords after partially input. Hence, if we
input `C-x t` to Emacs then `which-key` will display all defined key
chords that are prefixed with `C-x t`. Placement of which-key window
is on the bottom and pagination is done by `C-h n` for next and `C-h
p` for previous.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode t)
    (which-key-setup-side-window-bottom))
#+END_SRC
