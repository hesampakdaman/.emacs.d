#+TITLE: UI Enhancements
#+STARTUP: OVERVIEW
* Introduction
Settings for the feel and look of Emacs. We may also have some options
configured elsewhere which affects the look of Emacs. One such example
is the face `hideshow` minor mode uses, which we have put in
`programming.org` because it's directly related to programming.

* Cursor
We always want the cursor to always blink so we can easily find it.
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode t)
  (setq blink-cursor-blinks 0) ;; blink forever
#+END_SRC

Highlights current line in programming buffers, ie. in `prog-mode`
activated buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC

* Fonts
We set the default, fixed-pitch and variable-pitch fonts here. In
order to get good size we make configure the font size depending on
screen resolution.
#+BEGIN_SRC emacs-lisp
  (setq hesam-default-hires-height 180)
  (setq hesam-default-lowres-height 120)
  (setq hesam-modeline-hires-height (- hesam-default-hires-height 10))
  (setq hesam-modeline-lowres-height (- hesam-default-lowres-height 5))

  (set-face-attribute 'default nil
                      :family "IosevkaTerm Nerd Font"
                      :weight 'regular
                      :height hesam-default-lowres-height)
  (set-face-attribute 'fixed-pitch nil
                      :family "IosevkaTerm Nerd Font"
                      :weight 'regular)
  (set-face-attribute 'variable-pitch nil
                      :family "EBGaramond"
                      :height 1.5)
#+END_SRC

If we drag an Emacs frame between screens with different resolutions
we have to update all font sizes in that frame. The
`hesam/font-per-display` achieves that and we let it be run each time
a new frame is created and whenever it's moved.
#+BEGIN_SRC emacs-lisp
  (defun hesam/font-per-display (frame)
    "Will change the font according to the dimensions of the FRAME."
    (select-frame frame)
    (frame-monitor-attribute 'geometry frame)
    (cond ((> (car (last (frame-monitor-attribute 'geometry frame))) 1200)
           (set-face-attribute 'default frame :height hesam-default-hires-height)
           (set-face-attribute 'mode-line frame :height hesam-modeline-hires-height)
           (set-face-attribute 'mode-line-inactive frame :height hesam-modeline-hires-height))
          (t (set-face-attribute 'default frame :height hesam-default-lowres-height)
             (set-face-attribute 'mode-line frame :height hesam-modeline-lowres-height)
             (set-face-attribute 'mode-line-inactive frame :height hesam-modeline-lowres-height))))
  (add-hook 'after-make-frame-functions 'hesam/font-per-display)
  (add-hook 'move-frame-functions 'hesam/font-per-display)
#+END_SRC

* Frame customization and decorations
Remove the menu, scroll and toolbar from Emacs frame.
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
#+END_SRC
Use an undecorated frame to remove OS titlebar. We also add internal
border around the whole Emacs frame which pads the frame from all
sides.

The `drag-internal` settings is for using the mouse to drag/resize the
Emacs frame, useful for when we have an undecorated frame.
#+BEGIN_SRC emacs-lisp
  (dolist (frame-option
           '((undecorated . t) (internal-border-width . 10) (drag-internal-border . 1)))
    (add-to-list 'default-frame-alist frame-option))
#+END_SRC

Lastly we use a little margin on both sides. Mainly because we want
some padding between buffers. Recall that `internal-border` option is
only around the frame and does not apply in areas that do not touch a
frame edge.
#+BEGIN_SRC emacs-lisp
  (setq-default left-margin-width 1 right-margin-width 1)
#+END_SRC

* Mode-line
We like a compact mode-line
#+BEGIN_SRC emacs-lisp
  (setq mode-line-compact t)
#+END_SRC

and to remove the precentage and All/Top/Bottom indicator
#+BEGIN_SRC emacs-lisp
  (setq mode-line-percent-position nil)
#+END_SRC

To further clean-up the mode-line we will install `minions` that hides
them under the major mode. Now all relevant minor modes are shown
under a hidden list.
#+BEGIN_SRC emacs-lisp
  (use-package minions
    :config (minions-mode 1))
#+END_SRC

* Tabs and Windows
Start with configuring the behavior of the tab bar, for example we
enable the functionality and hide the close tab button.
#+BEGIN_SRC emacs-lisp
  (setq tab-bar-show 1	      ; show the tab bar if we have more 1 tab
        tab-bar-mode t
        tab-bar-close-button-show nil)
#+END_SRC

Next we decide what to display in the tab bar. This is done by adding
functions to a variable that does something in the tab bar (like
returning a string).
#+BEGIN_SRC emacs-lisp
  (setq tab-bar-format
        '(tab-bar-format-tabs         ; show tabs in the bar
          tab-bar-separator
          tab-bar-format-align-right  ; render the bar across the frame
          tab-bar-format-global))     ; show global strings from modeline
#+END_SRC

And then to quickly switch between tabs we bind convenient keys
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "s-n" 'tab-next
   "s-p" 'tab-previous)
#+END_SRC

We want to repeat closing tabs. Hence we insert it in the repeat-map
table.
#+BEGIN_SRC emacs-lisp
  (defvar tab-close-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "0") #'tab-close)
      map))
  (put 'tab-close 'repeat-map 'tab-close-repeat-map)
#+END_SRC

Use Dracula theme colors for the tab bar; we prefer it to be slighly
smaller than surrounding text. Otherwise inherit face attributes from
`'default`. We'll also add a line across the Emacs frame to separate
the tab bar from the buffer.
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'tab-bar nil
                      :inherit 'default
                      :height 0.95
                      :foreground (hesam/theme-color 'fg)
                      :background (hesam/theme-color 'bg)
                      :underline (hesam/theme-color 'current)
                      :box nil)
#+END_SRC

To differentiate between active/inactive tabs we make adjustments
to the text weight and colors.
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'tab-bar-tab nil
                      :inherit 'tab-bar
                      :weight 'bold
                      :foreground (hesam/theme-color 'pink)
                      :background (hesam/theme-color 'bg)
                      :underline (hesam/theme-color 'pink)
                      :box `(:line-width (1 . 10) :color ,(hesam/theme-color 'bg) :style nil))

  (set-face-attribute 'tab-bar-tab-inactive nil
                      :inherit 'tab-bar
                      :foreground (hesam/theme-color 'purple)
                      :background (hesam/theme-color 'bg)
                      :box `(:line-width (1 . 10) :color ,(hesam/theme-color 'bg) :style nil))
#+END_SRC

Define a function that kills all buffers associated with a window
#+BEGIN_SRC emacs-lisp
  (defun hesam/close-window-and-buffers ()
    "Kill all buffers associated with the current window, and then delete the window if possible."
    (interactive)
    (let* ((current-window (selected-window))
           (buffers (delq nil (mapcar (lambda (win)
                                        (when (eq win current-window)
                                          (window-buffer win)))
                                      (window-list)))))
      (mapc 'kill-buffer buffers)
      (unless (one-window-p t)
        (delete-window current-window))))
#+END_SRC

and build upon that to close the tab as well, bind this `C-x t k`.
#+BEGIN_SRC emacs-lisp
  (defun hesam/kill-buffer-on-close-tab ()
    (interactive)
    (hesam/close-window-and-buffers)
    (tab-close))

  ;; Usually we don't bind custom keys to C-x but make an exception this
  ;; time to gather all tab commands with the one defined.
  (general-define-key
   "C-x t k" 'hesam/kill-buffer-on-close-tab)
#+END_SRC

But sometimes we just want to kill next window in cyclic order and to
do that we make use of `other-window` function.
#+BEGIN_SRC emacs-lisp
  (defun hesam/switch-and-close-next-window ()
    "Switch to the next window in cyclic order, then kill the window."
    (interactive)
    (other-window 1)
    (delete-window))

  (leader-window
    "0" 'hesam/switch-and-close-next-window)
#+END_SRC

Enable `winner-mode` everywhere which will allow undo and redo for
tabs and windows. Windmove allows for easy navigation inside a
window. We configure windmove to wrap around when moving buffers
around (windmove is enabled by default).
#+BEGIN_SRC emacs-lisp
  (winner-mode t)
  (setq windmove-wrap-around t)
#+END_SRC

Under prefix `C-c w` we define keybindings for windmov's display
feature and winner mode. We are inspired by Vim bindings to allow for
fast display of next buffers. Winner mode is naturally bound to `u`
and `r`.
#+BEGIN_SRC emacs-lisp
  (leader-window
     "k" 'windmove-display-up
     "j" 'windmove-display-down
     "h" 'windmove-display-left
     "l" 'windmove-display-right
     "s" 'windmove-display-same-window
     "r" 'winner-redo
     "u" 'winner-undo)
#+END_SRC

Sometimes we have two windows in a frame and want to change
orientation from
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :config
    (leader-window
      "f" 'transpose-frame))
#+END_SRC

Here we bind convenient bindings for easy traversal between buffers in
a window. Additionally we define keys for swapping buffer locations.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "s-k" 'windmove-up
   "s-j" 'windmove-down
   "s-h" 'windmove-left
   "s-l" 'windmove-right

   "s-K" 'windmove-swap-states-up
   "s-J" 'windmove-swap-states-down
   "s-H" 'windmove-swap-states-left
   "s-L" 'windmove-swap-states-right)
#+END_SRC

* Theme switcher
#+BEGIN_SRC emacs-lisp
  (defvar light-theme 'modus-operandi)
  (defvar dark-theme 'dracula)
  (defvar global-current-theme dark-theme)
  (defvar global-next-theme light-theme)

  (load-theme global-current-theme t)

  (defun hesam/switch-theme (current-theme next-theme)
    (disable-theme current-theme)
    (load-theme next-theme t)
    (setq global-current-theme next-theme)
    (setq global-next-theme current-theme))

  (defun hesam/theme-toggle ()
    (interactive)
    (hesam/switch-theme global-current-theme global-next-theme))

  (defun hesam/switch-theme-dark ()
    (if (eq global-current-theme light-theme)
        (hesam/theme-toggle)))

  (defun hesam/switch-theme-light ()
    (if (eq global-current-theme dark-theme)
        (hesam/theme-toggle)))
#+END_SRC
* Packages
** Which-key
Displays available key chords after partially input. Hence, if we
input `C-x t` to Emacs then `which-key` will display all defined key
chords that are prefixed with `C-x t`.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+END_SRC
