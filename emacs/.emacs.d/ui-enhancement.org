#+TITLE: UI Enhancements
#+STARTUP: OVERVIEW
* Introduction
Settings for the feel and look of Emacs. We may also have some options
configured elsewhere which affects the look of Emacs. One such example
is the face `hideshow` minor mode uses, which we have put in
`programming.org` because it's directly related to programming.

* Fonts
** Family
The core of our text rendering in Emacs, the font family, is defined
here as a configurable variable, which ensures flexibility and
customization.
#+BEGIN_SRC emacs-lisp
  (defcustom hesam-default-font-family "IosevkaTerm Nerd Font"
    "Default font family."
    :type 'string
    :group 'hesam)
#+END_SRC

** Resolution-specific font sizes
To maintain a visually pleasing font size regardless of the display
resolution, we define custom variables that set the font height based
on whether the screen is high-resolution (HiRes) or low-resolution
(LowRes). The variables `hesam-hires-display-font-height` and
`hesam-lowres-display-font-height` control the font height values for
HiRes and LowRes displays, respectively.
#+BEGIN_SRC emacs-lisp
  (defvar hesam-hires-display-font-height-value 180
    "The actual value of 'hesam-hires-display-font-height'.")

  (defvar hesam-lowres-display-font-height-value 120
    "The actual value of 'hesam-lowres-display-font-height'.")

  (defcustom hesam-modeline-hires-height (floor (* hesam-hires-display-font-height-value 0.9))
    "Modeline high-resolution height."
    :type 'integer
    :group 'hesam)

  (defcustom hesam-modeline-lowres-height (floor (* hesam-lowres-display-font-height-value 0.9))
    "Modeline low-resolution height."
    :type 'integer
    :group 'hesam)
#+END_SRC

** Default font attributes
We explicitly set the attributes for the `'default`, `'fixed-pitch`,
and `'variable-pitch` fonts. These attributes include the font family,
weight, and height, the latter depending on the screen resolution.
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :family hesam-default-font-family
                      :weight 'regular
                      :height hesam-lowres-display-font-height-value)

  (set-face-attribute 'fixed-pitch nil
                      :inherit 'default)

  (set-face-attribute 'fixed-pitch-serif nil
                      :inherit 'default)

  ;; we need to set it expclitly otherwise Emacs will display with
  ;; this face with another font, see the start screen as an example
  (set-face-attribute 'variable-pitch nil
                      :family hesam-default-font-family
                      :inherit 'default)
#+END_SRC

** Font size adjustment functions
In scenarios where an Emacs frame is dragged between screens of
different resolutions, all font sizes within that frame must be
updated accordingly. The function `hesam/font-per-display` is designed
to handle this, and it's set to run every time a new frame is created
or moved.
*** Threshold
The variable `hesam-hires-resolution-threshold` sets the resolution
threshold for high-resolution displays.
#+BEGIN_SRC emacs-lisp
  (defvar hesam-hires-resolution-threshold-value 1200
    "The actual value of 'hesam-hires-resolution-threshold'.")
#+END_SRC

*** Functions
The functions `hesam/font-per-display` and `hesam/set-font-sizes` work
in tandem to adjust the font sizes based on the current screen
resolution.
#+BEGIN_SRC emacs-lisp
  (defun hesam/font-per-display (frame)
    "Adjust the font size based on the FRAME's resolution."
    (let* ((geometry (frame-monitor-attribute 'geometry frame))
           (resolution (car (last geometry))))
      (select-frame frame)
      (if (> resolution hesam-hires-resolution-threshold-value)
          (hesam/set-font-sizes frame hesam-hires-display-font-height-value hesam-modeline-hires-height)
        (hesam/set-font-sizes frame hesam-lowres-display-font-height-value hesam-modeline-lowres-height))))

  (defun hesam/set-font-sizes (frame default-height modeline-height)
    "Helper function to set the font sizes of FRAME."
    (set-face-attribute 'default frame :height default-height)
    (set-face-attribute 'mode-line frame :height modeline-height)
    (set-face-attribute 'mode-line-inactive frame :height modeline-height))
#+END_SRC

*** Custom variables
The following custom variables control the font height based on the
screen resolution. The `:set` attribute in each `defcustom` call is
used to automatically update the font sizes using the
`hesam/font-per-display` function whenever these variables are
changed.
#+BEGIN_SRC emacs-lisp
  (defcustom hesam-hires-display-font-height 180
    "Font height for high-resolution displays."
    :type 'integer
    :group 'hesam
    :set (lambda (sym value)
           (set-default sym value)
           (setq hesam-hires-display-font-height-value value)
           (hesam/font-per-display (selected-frame)))
    :get (lambda (sym) hesam-hires-display-font-height-value))

  (defcustom hesam-lowres-display-font-height 120
    "Font height for low-resolution displays."
    :type 'integer
    :group 'hesam
    :set (lambda (sym value)
           (set-default sym value)
           (setq hesam-lowres-display-font-height-value value)
           (hesam/font-per-display (selected-frame)))
    :get (lambda (sym) hesam-lowres-display-font-height-value))

  (defcustom hesam-hires-resolution-threshold 1200
    "Resolution threshold for high-resolution displays."
    :type 'integer
    :group 'hesam
    :set (lambda (sym value)
           (set-default sym value)
           (setq hesam-hires-resolution-threshold-value value)
           (hesam/font-per-display (selected-frame)))
    :get (lambda (sym) hesam-hires-resolution-threshold-value))
#+END_SRC
*** Hooks
Hooks are set up to ensure `hesam/font-per-display` is executed as
required, maintaining optimal font size regardless of the screen
resolution. This ensures that the font sizes are adjusted
automatically when we create a new frame or move an existing frame to
another screen.
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-make-frame-functions 'hesam/font-per-display)
  (add-hook 'move-frame-functions 'hesam/font-per-display)
#+END_SRC

* Themes
** Dracula
The name of the theme is `dracula` -- dark, sleek and ubiquitous with
lots of color!
#+BEGIN_SRC emacs-lisp
  (use-package dracula-theme
    :config
    (setq dracula-enlarge-headings nil)
    (add-hook
     'after-load-theme-hook
     (lambda (theme)
       (when (eq theme 'dracula)
         ;; We don't like the match face provided by Dracula so we change it
         ;; here -- as this should only be done if this theme is used.
         (set-face-attribute 'match nil :background "#bd93f9")))))
#+END_SRC

** Modus
#+BEGIN_SRC emacs-lisp
  (use-package modus-themes)
#+END_SRC

** Ef
#+BEGIN_SRC emacs-lisp
  (use-package ef-themes)
#+END_SRC

* Cursor
We always want the cursor to always blink so we can easily find it.
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode t)
  (setq blink-cursor-blinks 0) ;; blink forever
#+END_SRC

Highlights current line in programming buffers, ie. in `prog-mode`
activated buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC

* Frame customization and decorations
Remove the menu, scroll and toolbar from Emacs frame.
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
#+END_SRC
Use an undecorated frame to remove OS titlebar. We also add internal
border around the whole Emacs frame which pads the frame from all
sides.

The `drag-internal` settings is for using the mouse to drag/resize the
Emacs frame, useful for when we have an undecorated frame.
#+BEGIN_SRC emacs-lisp
  (dolist (frame-option
           '((undecorated . t) (internal-border-width . 10) (drag-internal-border . 1)))
    (add-to-list 'default-frame-alist frame-option))
#+END_SRC

Lastly we use a little margin on both sides. Mainly because we want
some padding between buffers. Recall that `internal-border` option is
only around the frame and does not apply in areas that do not touch a
frame edge.
#+BEGIN_SRC emacs-lisp
  (setq-default right-margin-width 1)
#+END_SRC

Do not truncate lines and if we need it the default binding to toggle
is `C-x x t`. A value of `t` means to NOT truncate lines.
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

Setting partial width windows to `nil` means to respect the value for
`truncate-lines`, otherwise we will get truncated lines for
horizontally split windows (ie. `C-x 3` windows).
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-partial-width-windows nil)
#+END_SRC

Set fringes to be invisible by inheriting from 'default. Hook it so it
updates when changing themes.
#+BEGIN_SRC emacs-lisp
  (add-hook
   'after-load-theme-hook
   (lambda (&optional args) (set-face-attribute 'fringe nil :background 'unspecified)))
#+END_SRC

* Mode-line
We like a compact mode-line and since VC mode will display potentially
long branch names we remove it from the mode-line. To be safe we
remove it after startup to ensure it is set when we try and delete it.
#+BEGIN_SRC emacs-lisp
  (setq mode-line-compact t)
  (add-hook
   'emacs-startup-hook
   (lambda ()
     (delete '(vc-mode vc-mode) mode-line-format)))
#+END_SRC

and to remove the precentage and All/Top/Bottom indicator.
#+BEGIN_SRC emacs-lisp
  (setq mode-line-percent-position nil)
#+END_SRC

Remove global info from the mode-line. Otherwise `display-time-mode`
will display the time on every mode-line bar since
`mode-line-misc-info` carries the global-string. We instead opt for
the tab-bar to include the global-info-string since for each frame we
have only one tab-bar. At the time of writing, as you'll see below, we
need to wait until the mode-line-misc-info is set and safest is to do
it after startup.
#+BEGIN_SRC emacs-lisp
  (add-hook
   'emacs-startup-hook
   (lambda ()
     (delete '(global-mode-string ("" global-mode-string)) mode-line-misc-info)))
#+END_SRC

To further clean-up the mode-line we will install `minions` that hides
them under the major mode. Now all relevant minor modes are shown
under a hidden list.
#+BEGIN_SRC emacs-lisp
  (use-package minions
    :config (minions-mode 1))
#+END_SRC

* Tabs and Windows
Start with configuring the behavior and look of the tab bar, for
example we enable the functionality and hide the close tab button.
#+BEGIN_SRC emacs-lisp
  (setq tab-bar-mode t
        tab-bar-close-button-show nil
        tab-bar-auto-width nil)
#+END_SRC

Sets the look of tab bar. We choose =not= to extenuate it and let it
melt with the 'default background. However, we make sure to have a
divider -- using `:underline` to highlight where the tab-bar starts.
#+BEGIN_SRC emacs-lisp
  (defun hesam/set-tab-face-attributes ()
    "Set the face attributes for the tab-bar and its tabs.

    This function achieves the following:
    1. Configures the default appearance of the tab-bar to match the default
       face's foreground and background, with adjustments for height, font
       family, weight, and underlining.
    2. Differentiates between active and inactive tabs by setting distinct
       face attributes. Active tabs have a more pronounced appearance
       with an ultra-bold weight, while inactive tabs are lighter.

    Prerequisites:
    - Requires the default face's foreground and background to be set.
    - Relies on the `hesam-default-font-family` variable for font specification.

    Note: The function should be invoked after any theme or face customizations
    to ensure consistency with the default face attributes."
    (when (and (face-foreground 'default) (face-background 'default))
        (set-face-attribute 'tab-bar nil
                        :height 0.95
                        :family hesam-default-font-family
                        :weight 'normal
                        :foreground (face-foreground 'default)
                        :background (face-background 'default)
                        :underline (face-foreground 'default)
                        :box nil)

    ;; To differentiate between active/inactive tabs we make adjustments
    ;; to the text weight.
    (set-face-attribute 'tab-bar-tab nil
                        :inherit 'tab-bar
                        :weight 'ultra-bold
                        :underline (face-foreground 'default)
                        :box `(:line-width (1 . 10) :color ,(face-background 'default) :style nil))

    (set-face-attribute 'tab-bar-tab-inactive nil
                        :inherit 'tab-bar
                        :weight 'light
                        :box `(:line-width (1 . 10) :color ,(face-background 'default) :style nil))))

  ;; Run the function to set the look
  (hesam/set-tab-face-attributes)

  ;; And add it as a hook to adhere with changes when switching theme
  ;; during run-time.
  (add-hook
   'after-load-theme-hook
   (lambda (&optional theme) (hesam/set-tab-face-attributes)))
#+END_SRC

Next we decide what to display in the tab bar. This is done by adding
functions to a variable that does something in the tab bar (like
returning a string). The `tab-bar-format-global` option will display
info that are of _global_ nature, such as the time with
`display-time-mode`.
#+BEGIN_SRC emacs-lisp
  (setq tab-bar-format
        '(tab-bar-format-tabs
          tab-bar-separator
          tab-bar-format-align-right
          tab-bar-format-global))
#+END_SRC

However, the tab bar format tabs string prepends a separator on the
very left side. We'll remove it.
#+BEGIN_SRC emacs-lisp
  (advice-add
   'tab-bar-format-tabs :around (lambda (orig-fun) (cdr (funcall orig-fun))))
#+END_SRC

Next we want all tabs to be displayed in UPCASE. The function that
automatically names tabs is `tab-bar-tab-name-current` which we
decorate.
#+BEGIN_SRC emacs-lisp
  (defun hesam/uppercase-tab-name-current (original-function &rest args)
    (upcase (apply original-function args)))
  (advice-add 'tab-bar-tab-name-current :around #'hesam/uppercase-tab-name-current)
#+END_SRC

And to quickly switch between tabs we bind convenient keys
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "s-n" 'tab-next
   "s-p" 'tab-previous)
#+END_SRC

We want to repeat closing tabs. Hence we insert it in the repeat-map
table.
#+BEGIN_SRC emacs-lisp
  (defvar tab-close-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "0") #'tab-close)
      map))
  (put 'tab-close 'repeat-map 'tab-close-repeat-map)
#+END_SRC

Define a function that kills all buffers associated with a window
#+BEGIN_SRC emacs-lisp
  (defun hesam/close-window-and-buffers ()
    "Kill all buffers associated with the current window, and then delete the window if possible."
    (interactive)
    (let* ((current-window (selected-window))
           (buffers (delq nil (mapcar (lambda (win)
                                        (when (eq win current-window)
                                          (window-buffer win)))
                                      (window-list)))))
      (mapc 'kill-buffer buffers)
      (unless (one-window-p t)
        (delete-window current-window))))
#+END_SRC

and build upon that to close the tab as well, bind this `C-x t k`.
#+BEGIN_SRC emacs-lisp
  (defun hesam/kill-buffer-on-close-tab ()
    (interactive)
    (hesam/close-window-and-buffers)
    (tab-close))

  ;; Usually we don't bind custom keys to C-x but make an exception this
  ;; time to gather all tab commands with the one defined.
  (general-define-key
   "C-x t k" 'hesam/kill-buffer-on-close-tab)
#+END_SRC

But sometimes we just want to kill next window in cyclic order and to
do that we make use of `other-window` function.
#+BEGIN_SRC emacs-lisp
  (defun hesam/switch-and-close-next-window ()
    "Switch to the next window in cyclic order, then kill the window."
    (interactive)
    (other-window 1)
    (delete-window))

  (leader-window
    "0" 'hesam/switch-and-close-next-window)
#+END_SRC

Enable `winner-mode` everywhere which will allow undo and redo for
tabs and windows. Windmove allows for easy navigation inside a
window. We configure windmove to wrap around when moving buffers
around (windmove is enabled by default).
#+BEGIN_SRC emacs-lisp
  (winner-mode t)
  (setq windmove-wrap-around t)
#+END_SRC

Under prefix `C-c w` we define keybindings for windmov's display
feature and winner mode. We are inspired by Vim bindings to allow for
fast display of next buffers. Winner mode is naturally bound to `u`
and `r`.
#+BEGIN_SRC emacs-lisp
  (leader-window
     "k" 'windmove-display-up
     "j" 'windmove-display-down
     "h" 'windmove-display-left
     "l" 'windmove-display-right
     "s" 'windmove-display-same-window
     "r" 'winner-redo
     "u" 'winner-undo)
#+END_SRC

Sometimes we have two windows in a frame and want to change
orientation from
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :config
    (leader-window
      "f" 'transpose-frame))
#+END_SRC

Here we bind convenient bindings for easy traversal between buffers in
a window. Additionally we define keys for swapping buffer locations.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "s-k" 'windmove-up
   "s-j" 'windmove-down
   "s-h" 'windmove-left
   "s-l" 'windmove-right

   "s-K" 'windmove-swap-states-up
   "s-J" 'windmove-swap-states-down
   "s-H" 'windmove-swap-states-left
   "s-L" 'windmove-swap-states-right)
#+END_SRC

* Marginalia
This package displays helpful descriptions of on the margins in
certains instances. For example: invoking `M-x` displays all commands
that can be called interactively. `Marginalia` will show their
descriptions on the right hand side -- at the margin if you will.
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode))
#+END_SRC

* Which-key
Displays available key chords after partially input. Hence, if we
input `C-x t` to Emacs then `which-key` will display all defined key
chords that are prefixed with `C-x t`. Placement of which-key window
is on the bottom and pagination is done by `C-h n` for next and `C-h
p` for previous.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode t)
    (which-key-setup-side-window-bottom))
#+END_SRC
